
百练 4150:上机
查看 提交 统计 提示 提问
总时间限制: 1000ms 内存限制: 65536kB
描述
又到周末了，同学们陆陆续续开开心心的来到机房上机。jbr也不例外，但是他到的有点晚，发现有些机位上已经有同学正在做题，有些机位还空着。细心的jbr发现，一位同学来到机房，坐在机位i上，如果他的左右两边都空着，他将获得能力值a[i]；如果当他坐下时，左边或者右边已经有一个人在上机了，他将获得能力值b[i]；如果当他坐下时，他的左边右边都有人在上机，他将获得能力值c[i]。

同时他发现，已经在上机的同学不会受到刚要坐下的同学的影响，即他们的能力值只会在坐下时产生，以后不会发生变化;第一个机位左边没有机位，最后一个机位右边没有机位，无论何时坐在这两个机位上将无法获得c值。

这时jbr发现有一排机器还空着，一共有N个机位，编号1到N。这时有N位同学们陆陆续续来到机房，一个一个按照顺序坐在这排机位上。聪明的jbr想知道怎么安排座位的顺序，可以使这N位同学获得能力值的和最大呢？

输入
第一行一个整数N(1<= N <= 10000)

第二行N个数，表示a[i]

第三行N个数，表示b[i]

第四行N个数，表示c[i]

(1<= a[i],b[i],c[i] <=10000)
输出
一个整数，表示获得最大的能力值和
样例输入
4
1 2 2 4
4 3 3 1
2 1 1 2
样例输出
14
提示
第一位同学坐在第四个机位上，获得能力值4；
第二位同学坐在第三个机位上，获得能力值3；
第三位同学坐在第二个机位上，获得能力值3；
第四位同学坐在第一个机位上，获得能力值4；
总和为14。

解题思路：
  这是一道动态规划求解最优解的问题。
  对于每个位置都有三种可能情况，一、左右都没有人坐。二、左边或者后边有人坐了。三、左边右边都已经有人坐了。
  对于每个位置，我们只要找到三种情况中的最大值就可以。
  递推方程：
  f[][]二维数组。
  f[0][i]表示左边和右边都没有人和有一边有人的最大值。
  f[1][i]表示左边都有人或者是只有一边有人的最大值。
  递推边界：（非常重要）
  对于第一个位置，左边没有人上机，永远不可能为c[i]，这就为递推提供了条件
  f[0][1]=a[1]：表示第一个位置的右边没有人上机的情况。
  f[0][1]=b[1]:表示第一个位置的右边有人在上机的情况。
  代码：
  
  
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
const int maxn=10001;
int a[maxn];
int b[maxn];
int c[maxn];
int f[2][maxn];
int n;
int main()
{
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&a[i]);
	}
	for(int i=1;i<=n;i++){
		scanf("%d",&b[i]);
	}
	for(int i=1;i<=n;i++){
		scanf("%d",&c[i]);
	}
	f[0][1]=a[1];
	f[1][1]=b[1];
	for(int i=2;i<=n;i++)
	{
		f[0][i]=max(f[0][i-1]+b[i],f[1][i-1]+a[i]);
		f[1][i]=max(f[0][i-1]+c[i],f[1][i-1]+b[i]);
	}
	printf("%d\n",f[0][n]);
	return 0;
}
